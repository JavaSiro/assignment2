#b
# price=[10,20,30,40]
# price[0]=f'${1}'
# price[1]=f'${2}'
# price[2]=f'${3}'
# price[3]=f'${4}'
# print(price)

#c
# fruits=['apple', 'banana', 'orange', 'tangerine']
# fruits.extend(['pineapple', 'peach'])
# print(fruits)

#d
# fruits=['apple', 'banana', 'orange', 'tangerine']
# for i in ['orange', 'tangerine']:
#     fruits.remove(i)
#     print(fruits)

#e
# fruits=['apple', 'orange', 'tangerine', 'watermelon']
# price=['$1','$2','$3','$4']
# a=zip(fruits,price)
# for b,c in a:
#     print(f'{b} is {c}')

#f
# cars=['bmw', 'mercedes', 'toyota', 'chevrolet', 'volvo', 'tesla', 'audi']
# print(sorted(cars))

#g
# cars=['bmw', 'mercedes', 'toyota', 'chevrolet', 'volvo', 'tesla', 'audi']
# newcars=[]
# for i in range(4,7):
#     newcars.append(cars[i])
# print(newcars)

#h
# mylist=[1,2,3,4,5] kinda super set, with many tricks possible to imply
# myset={1,2,3,4,5} used for unique data, it doesn't output duplicates, better efficiency
# mytuples=(1,2,3,4,5) / mytuples=1,2,3,4,5 cannot be changed, i have no idea why we need it, it says that tuples r not even more efficient

#i
# x= ('apple', 'banana', 'cherry')
# convert=list(x)
# convert[0]='kiwi'
# print(convert)

#j
# A=('a', 'b', 'c')
# B=(1,2,3)
# comb=A+B
# print(comb)

#k
# dict={'iphone':'16', 'price':1200, 'inch':6.1}
# print(dict)

#l
# cars={'nexia':'white'}
# cars['malibu']='black'
# print(cars)

#m
# cars={'nexia':'white'}
# cars['nexia']='black'
# print(cars)
# unfortunately key must be unique, so adding and updating work same

#n
# cars={'ferrari':'red', 'bmw':'black'}
# for key,value in cars.items():
#     print(f'{key} is {value}')

#o
cars={'ferrari':'red', 'bmw':'black'}
neworder=[]
if cars.keys.len
-               